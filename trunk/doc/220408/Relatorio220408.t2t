Relatório Parcial de Andamento do TG @nl Localização de Texto em Imagem
Laerte Alves de Almeida Junior GRR20042353 @nl Rafael Charan GRR20053297
%%date(%d/%m/%Y)

%!postproc(html): '<IMG' '<IMG WIDTH=30% HEIGHT=45%'
%!postproc(tex): 'includegraphics([a-zA-Z0-9/}{.]+)@(\d)x(\d)' 'includegraphics[width=\2cm,height=\3cm]\1'
%!postproc(tex): 'includegraphics([a-zA-Z0-9/}{.]+)@' 'includegraphics[width=7cm,height=5cm]\1'
%!postproc(html): @nl "<br>"
%!postproc(tex): @nl '\\\\'
%!postproc(tex): @np '\\newpage'
%!postproc: @np ''
%!style(tex): babel
%!postproc(tex): '{babel}' '[brazil]{babel}'
%!postproc(tex): 'documentclass\[(.+)\]\{article\}' 'documentclass[\1,twocolumn]{article}'
%!postproc(tex): '\\clearpage' '%\\clearpage'
%!encoding: utf-8


=Implementação do algoritmo=


==Bases==
Para o reconhecimento de regiões da imagem que são consideradas texto, assumimos que estas regiões contém muita variação de cor nos pixels. Isso porque nas regiões de transição entre o fundo da imagem e a fonte do texto, há uma diferença de cores bastante acentuada dada a borda das letras. 

A avaliação de similaridade/transição de cores dos pixels, é feita a partir de uma constante fornecida para o algoritmo, que é o quanto a cor de um pixel pode variar de outro, sendo que os dois ainda são considerados similares.	

Baseando-se nessa idéia, o algoritmo procura o primeiro pixel da linha, que é destoante dos pixels lidos até então (possivelmente, de fundo). 
==Intervalos de Variancia==
De posse da posição desse pixel, é feita uma leitura dos pixels adiante, buscando a similaridade deles com a do pixel anteriormente encontrado. Essa leitura, é feita dentro de um limite máximo de pixels à frente, estipulado manualmente. Se a região adiante atingir o limite máximo de homogeneidade, ela será descartada, pois não há variação significativa. 

Se a região à frente não atingir o limite máximo, e continuar variando com regiões de cores homogêneas ainda menores que o limite, a leitura prosseguirá até que haja uma região que passe do limite, ou que seja atingido o limite de largura da imagem.

Para delimitar o intervalo com variação significativa, é guardada a última posição com pixels discrepantes, na leitura de uma região que ainda não atingiu o limite de homogeneidade.	Depois de feita a leitura de cada linha da imagem, são guardados os intervalos significativos de pixels, em estruturas próprias que contém as coordenadas x e y (início e fim).

==Determinação das Regiões de Texto==
Dados os intervalos encontrados pelo algoritmo, é aplicado um algoritmo de geometria computacional que é encarregado de fazer a união desses intervalos, a fim de formar uma região retangular que delimita a região que é considerada como região de texto da imagem.

Essa união é feita com uma estrutura temporária, que guarda os retângulos até então válidos. De começo, esses retângulos nada mais são do que as regiões da primeira linha onde foi encontrado algum intervalo válido.

Passada a primeira linha, serão avaliados os intervalos da linha seguinte para descobrirmos se há concomitância entre eles. Se houver, serão assumidas as coordenadas horizontais do intervalo maior e as coordenadas verticais do rodapé, serão as do último intervalo lido (pois a leitura é feita de cima para baixo na imagem). Sendo assim, as coordenadas verticais do cabeçalho do retângulo serão sempre as do primeiro intervalo lido que possui concomitância com outros.

Assim por diante, serão analisadas as próximas linhas, sempre comparando-as com os retângulos existentes até então na estrutura temporária.

A distância vertical máxima, entre as coordenadas do rodapé dos retângulos até então construídos, e o intervalo que está sendo lido no momento, para que este seja considerado concomitante (além da avaliação horizontal) é definida também por uma constante informada ao algoritmo.

Como conseqüência do teste de concomitância, o algoritmo também une retângulos que estão em uma mesma linha horizontal, mas com distância muito grande entre si (maior que a constante de homogeneidade definida no algoritmo), se houver um intervalo logo abaixo dessa linha que é concomitante com os dois (ou mais) intervalos logo acima.

Isso é bastante interessante para o caso de, na varredura das primeiras linhas, só sejam encontradas pequenas regiões com variações significativas, como por exemplo, na frase "teste inteligente". Nas primeiras linhas de varredura, só serão encontrados os pingos da letra "i" e a parte de cima das letras "t" e "l", que mesmo estando com uma grande distância entre si, não deixam de fazer parte da mesma região. 

Quando a união dos intervalos prosseguir para as linhas abaixo, será encontrado algum intervalo concomitante com todas as pequenas regiões definidas pelas linhas acima, que corresponde a parte central das letras, onde se encontra um intervalo de maior variancia.


==Resultados==

Dessa maneira, ao término do algoritmo, estaremos de posse das regiões onde possivelmente há texto, delimitadas pelos retângulos construídos anteriormente. 

Seguem abaixo duas imagens resultantes da aplicação do nosso programa com os parametros //homogeneidade:5,similaridade:10 e distancia vertical:5//.

%COLOCAR IMAGEM CAGADA
[imagensRelatorio22042008/jinnaiConstanteIncorretaWindowsv5l10s15.jpg]@

[imagensRelatorio22042008/resultadoWindowsInicialv5l10s15.jpg]@

=Refinamento do algoritmo de localização de intervalos=

Baseando-se no feedback obtido com os testes realizados com a nossa base de imagens de testes, na implementação anterior do algoritmo, buscou-se refinar a busca de intervalos válidos, afim de implementar uma heurística que assume que numa região de texto a cor (do texto) é única.

Partindo-se desse princípio, o algoritmo de localização de intervalos, foi modificado para que após lida uma região homogênea na cor do texto (menor que a constante de homogeneidade, portanto válida), a próxima região só seja considerada como parte do intervalo, se os pixels que tem cores discrepantes do fundo, também tem cor similar à cor dos pixels encontrados no primeiro intervalo válido da linha. 

Dessa maneira, não serão mais consideradas regiões da imagem com muita variação, mas onde a variação não faz sentido. Por exemplo, numa fotografia de uma nuvem, haverá muita variação próximo as bordas dessa nuvem, que poderia anteriormente ser considerada como texto (pois provavelmente não haverá região homogênea maior que o limite), mas que não faz sentido algum dentro da nossa busca.

Para refinar o algoritmo, precisamos apenas de mais uma variável para guardar a cor do primeiro intervalo válido e mais uma variável de controle que diz se o próximo intervalo interessa ou não. Dada a varredura do intervalo, após a primeira faixa de pixels homogêneos na cor do texto, teremos um próximo pixel de cor discrepante que assumimos pertencer ao fundo da imagem. Nesse ponto, nossa variável de controle diz que o intervalo à seguir não é válido, pois última cor lida é discrepante. 

Continuando a leitura dos pixels adiante e considerando que eles são homogêneos, porém não da cor que interessa, se for encontrada um pixel de cor diferente após esse intervalo homogêneo, este último intervalo lido não será considerado válido, pois marcamos na variável de controle que o próximo intervalo lido não seria válido. Suponha que a cor do pixel discrepante da região homogênea não válida, é igual a cor dos pixels encontrados no intervalo válido anterior. Se isto acontecer, a variável de controle será setada para considerar o próximo intervalo como válido. 

Ou seja, no próximo intervalo de cor homogênea lido, onde esta cor é a cor que interessa, quando houver um pixel de cor discrepante que determina o fim desse intervalo, ele será considerado como válido e a variável setada para que o próximo intervalo não seja válido (pois agora a cor discrepante não é similar a cor que nos interessa). 

Se após a leitura do primeiro intervalo homogêneo não válido (após o primeiro válido), for encontrado um pixel de cor discrepante da cor desse intervalo, mas que também não é igual a cor do intervalo inicial, a leitura prosseguirá, mas com a variável de controle marcada de maneira que o próximo intervalo de cor homogênea não será considerado como válido. 

Desse modo, a leitura prossegue até o fim da imagem, ou até que seja atingida a constante de homogeneidade como acontecia antes, porém apenas considerando os intervalos que tem cor parecida ao primeiro encontrado. 

Este refinamento do algoritmo, foi muito importante para conseguir discernir regiões que contém pequenas imagens aninhadas a posição vertical do texto, que acabavam sendo consideradas como partes do texto também.

Não só as imagens aninhadas à texto, mas também as regiões que contém muita variação com cores não parecidas passaram a ser descartadas após essas modificações, como exemplo, as bordas de nuvens já citadas anteriormente, ícones de uma área de trabalho, ou qualquer tipo de objeto de cor não homogênea e discrepante ao fundo que poderia errôneamente ser considerado como região de texto.


=Problemas encontrados nos resultados até então=
 
 Após o refinamento, o algoritmo mostrou-se bastante eficiente para selecionar o texto das mais variadas imagens, até mesmo com fundo complexo. O problema é que dadas as variações de fonte presentes no texto, o algoritmo fica dependente de constantes que delimitam as regiões a serem buscadas.

 São essas as constantes de similaridade, de homogeneidade, de distância vertical máxima e por último, a de tamanho mínimo de regiões válidas. 

 A primeira constante, não tão problemática até esse ponto, determina a diferença máxima aceitável entre dois pixels para que estes sejam considerados de cor semelhante. Ou seja, é o valor que o algoritmo utiliza, para diferenciar o possível texto do fundo da imagem. O problema é que dadas as diferentes imagens que o algoritmo pode analisar, não é interessante que a comparação seja baseada em um valor fixo, visto que as cores de fundo e texto podem variar, de maneira que alguma região de texto passe despercebida (seja considerada como uma região que faz parte do fundo).

 A segunda constante citada (homogeneidade) representa até o momento, o maior empecilho para o funcionamento genérico do algoritmo. Ou seja, até então, é necessário que essa constante seja configurada manualmente para cada imagem analisada, de maneira correta para que seja obtida a melhor seleção das regiões de texto. Isso porque, esse é o valor utilizado para determinar quais intervalos de pixels dentro da varredura de cada linha são variantes o suficiente para serem considerados como válidos (variancia é o parâmetro para a busca).

 Em outras palavras, essa constante está ligada diretamente ao tamanho da fonte contido na imagem analisada. Sendo assim, a dificuldade até então, é justamente determinar esse valor de maneira automática. Vale lembrar, que dado o funcionamento da busca (que procura regiões variantes em pixels, mas de cor homogênea), se a constate encontrada for compatível com a maior fonte do texto, as regiões com fontes pequenas ainda serão encontradas corretamente. A recíproca não é verdadeira, pois o algoritmo não encontra regiões com fontes grandes, se a constante estiver com um valor muito pequeno.

 Para tentar solucionar este problema, foi investido algum tempo nas últimas reuniões da equipe, fazendo alguns cálculos de média de tamanho dos intervalos obtidos e também da mediana do tamanho dos intervalos obtidos.

 Ou seja, em um primeiro momento, a idéia foi começar com um valor fixo na constante, razoavelmente grande, que seria então estabilizado de acordo com as características da imagem, fazendo-se os cálculos acima citados, a cada novo intervalo válido encontrado. 

 No cálculo da média, o cálculo sempre tendeu a 1 (1 pixel de tamanho do intervalo), pois era muito influenciado por pequenas regiões encontradas muitas vezes na imagem. A mediana, da mesma maneira não ficou precisa, pois apesar de ter um valor maior, ainda não era suficiente para cobrir todos os casos.

 Sendo assim, neste momento, compreendemos que o foco principal é encontrar uma maneira para determinar o valor dessa constante, porém precisamos de mais base teórica ou idéias mais fundamentadas a esse respeito. Pois finalizada essa parte, o algoritmo se tornará muito mais poderoso e eficiente.

 Sobre a constante de distância vertical máxima (utilizada na união vertical de intervalos em linhas diferentes), entendemos que existe uma relação muito forte com a constante de homogeneidade, pois o tamanho vertical de fontes, normalmente possui alguma relação de proporcionalidade com a largura.

 Já a constante de tamanho mínimo de regiões válidas (no momento, definida diretamente no código), possivelmente também possui alguma relação com a de homogeneidade, no sentido de que devemos desprezar apenas as variações que são pequenas demais para serem algum tipo de fonte, mas não as fontes pequenas em relação a maior presente na imagem. Ou seja, temos idéia de que essa análise deve levar em conta a localidade desse intervalo e os demais que foram encontrados na sua proximidades.
 
% contrastar a imagem obtida do Windows  com suas constantes e a jinnai

Segue abaixo as imagens resultantes após as nossas melhorias, sendo a primeira imagem com a constante de //homogeneidade:12// e a outra com //homogeneidade:5//. Os demais valores de constantes para ambas imagens seguem os mesmos.

[imagensRelatorio22042008/jinnaiConstanteCorretav12l10s15.jpg]@

[imagensRelatorio22042008/resultadoWindowsAposMelhoriav5l10s15.jpg]@


=Conclusão=

De maneira simples, já conseguimos encontrar o nosso objeto de análise (regiões textuais). Porém, como imagens em vídeo são geralmente muito complexas e contém textos das mais variadas fontes e tamanhos, seria interessante que o algoritmo fosse um pouco mais genérico e robusto para se adequar a maioria dos casos.

Sendo assim, esperamos investir mais uma quantia de tempo na resolução desse problema no reconhecimento de imagens, para então seguirmos adiante na segmentação de vídeo propriamente dita e estruturas de armazenamento das informações coletadas.

